---
title: '蓝桥杯 --- n皇后问题'
categories:
- 蓝桥杯
tags:
- dfs搜索
---

内容简介 : dfs搜索n皇后

---

- 试题内容  ---  n皇后

  n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

  ![1_597ec77c49-8-queens.png](https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png)

  现在给定整数n，请你输出所有的满足条件的棋子摆法。

  #### 输入格式

  共一行，包含整数n。

  #### 输出格式

  每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。

  其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。

  每个方案输出完成后，输出一个空行。

  输出方案的顺序任意，只要不重复且没有遗漏即可。

  #### 数据范围

  1≤n≤9

  #### 输入样例：

  ```
  4
  ```

  #### 输出样例：

  ```
  .Q..
  ...Q
  Q...
  ..Q.
  
  ..Q.
  Q...
  ...Q
  .Q..
  ```

---

* 思路：n皇后搜索问题
* 我的代码 

```
//使用dfs来搜索八皇后的解法
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;

const int N = 20;
int n;
char g[N][N];
bool row[N],col[N],dg[N * 2],udg[N * 2];

void dfs(int x,int y,int s)
{
    //判断边界
    if(s > n)return;
    //转向
    if(y == n){
        y = 0;
        x++;
    }
    //最后查找
    if(x == n){
        if(s == n){
            for(int i = 0;i < n; i++){
                puts(g[i]);
            }
            puts(" ");
        }
        return;
    }
    
    //不放
    g[x][y] = '.';
    dfs(x,y+1,s);
    
    //放
    if(!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]){
        
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x,y+1,s+1);
        g[x][y] = '.';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
    }
    
}


int main()
{
  cin >> n;
  for(int i = 0; i < n; i++)
  {
      for(int j = 0; j < n; j++)
      {
          g[i][j] = '.';
      }
  }
  dfs(0,0,0);
  return 0;
}

```



---

* 思路：使用全排列方式来搜索n皇后问题 --- 按照行来进行搜索问题
* 我的代码 

```
//使用全排列的方式来搜索八皇后的解法
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;

const int N = 20;
int n;
char g[N][N];
bool col[N],dg[N],udg[N];

void dfs(int u)
{
    if(u == n)
    {
        for(int i = 0; i < n; i++)
        {
            puts(g[i]);
        }
        puts(" ");
        return;
    }

    for(int i = 0;i < n; i++)
    {
        if(!col[i] && !dg[u + i] && !udg[n - u + i]) //col代表当前的列  dg代表正对角线  udg代表范对角线
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
    }

}

int main()
{
  cin >> n;
  for(int i = 0; i < n; i++)
  {
      for(int j = 0; j < n; j++)
      {
          g[i][j] = '.';
      }
  }
  dfs(0);
  return 0;
}
```




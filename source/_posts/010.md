---
title: '蓝桥杯--正则问题'
categories:
- 蓝桥杯
tags:
- dfs搜索
- 算法



---

内容简介 : 蓝桥杯历年题目  

---

- 试题内容  ---   正则问题

考虑一种简单的正则表达式：

只由 x ( ) | 组成的正则表达式。

小明想求出这个正则表达式能接受的最长字符串的长度。

例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6。

#### 输入格式

一个由x()|组成的正则表达式。

#### 输出格式

输出所给正则表达式能接受的最长字符串的长度。

#### 数据范围

输入长度不超过100，保证合法。

#### 输入样例：

```
((xx|xxx)x|(x|xx))xx 
```

#### 输出样例：

```
6
```

---

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
string str;
int k;
int dfs()
{
    int res = 0;
    
    while(k < str.size())
    {
        if(str[k] == '(')
        {
            k++;  //跳过左括号
            res += dfs();
            k++;  //跳过右括号
        }
        else if(str[k] == '|')
        {
            k++; //跳过这个与符号
            res = max(res,dfs());
        }else if(str[k] == ')')
        {
            break;
        }else{
            k ++; //跳过了 'x'
            res ++;
        }
    }    
    return res;
}

int main()
{
    cin >> str;
    
    cout << dfs() << endl;
    return 0;
}
```

---


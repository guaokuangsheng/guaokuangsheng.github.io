---
title: '面试题1 -- 链表版归并排序'
categories:
- 面试题
tags:
- 链表
- 归并排序



---

内容简介 : 常见面试题

---

- 试题内容  ---  链表版归并排序

  给定一个单链表，请使用 O(nlogn)O(nlogn) 的时间复杂度和额外 O(1)O(1) 的空间复杂度对其进行排序。

  样例1
  输入：4->2->1->3
  输出：1->2->3->4
  样例2
  输入：-1->5->3->4->0
  输出：-1->0->3->4->5

---

* 思路：归并加上不断迭代，解决系统栈问题
* 我的代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
      int n = 0; //记录链表长度
      for(ListNode *p = head; p; p = p->next) n++;
      
      ListNode *dummy = new ListNode(-1);
      dummy->next = head;
      
      //二路归并排序
      for(int i = 1; i < n; i *= 2)
      {
        ListNode* begin = dummy;
        for(int j = 0; j + i < n; j += i * 2)
        {
          ListNode *first = begin->next,*second = irst;
          for(int k = 0; k < i; k++)
          {
            second = second->next;
          }
          int f = 0,s = 0; //f->二路归并第一段指针 s->二路归并第二段指针
          //循环操作
          while(f < i && s < i && second)
          {
            	if(first->val < second->val)
              {
                begin = begin->next = first;
                first = first->next;
                f ++ ;
              }else{
                begin = begin->next = second;
                second = second->next;
                s ++ ;
              }
          }
          
          while(f < i)
          {
            begin = begin->next = first;
            first = first->next;
            f++;
          }
          
          while(s < i)
          {
            begin = begin->next = second;
            second = second->next;
            s++;
          }
          begin->next = second;
        }
      }
      return dummy->next;
    }
  
};
```



---


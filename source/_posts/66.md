---
title: '大鱼吃小鱼，小鱼吃虾米'
categories:
- 蓝桥杯校内选拔赛
tags:
- 20级第十二届蓝桥杯第2次周赛







---

内容简介 : 较难

* 出题人 : 朱俊老师

  

---

- 试题内容  ---   大鱼吃小鱼，小鱼吃虾米

  

## 题目描述

大鱼吃小鱼，小鱼吃虾米

在自然界之中存在这样一种大鱼吃小鱼，小鱼吃虾米的弱肉强食的关系。



我们可以形式化进行定义 M 吃 X , X 吃 Y，Y 吃 M。这样就形成了一种环状关系。



现有如下问题 : 


M,X,Y每一个代表一种生物，但是并不能确切的确定他们的对应关系。

<1>. 如若 "A M X",那么M 和 X就是属于同一阶层的生物。

对于n个生物我们都可以使用上述两种定义进行说明。

但是根据常识若满足以下三种情况，那么这种定义就是错误的。

<2>. 若当前的定义中当前的M 和 X 比生物总个数n大，那么就是错误的;



你需要根据上述规则，给定你n个生物，k个定义,



输出错误的定义的个数。



数据范围: 



1<= n <= 10000; 



## 输入

给定n和k,都是整数,中间用空格隔开

接下来每一行一个op,M,X,中间用空格隔开，op代表定义的两种类型:

若 op == 'A' 那么表示 M，X 是同一阶层的生物。

若 op == 'B' 那么表示 M 和 X就是属于M是X的上一层生物，M可以吃掉X

## 输出

错误定义的个数

## 样例输入

```
50 5
A 55 1
B 1 2
B 2 3
A 2 1
B 2 2
```

## 样例输出

```
3
```

## 提示



---

* 我的代码

```java
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <map>
#include <set>
using namespace std;
 
int n;
int k;
 
char op;
int x;
int y;
 
const int N = 5e4 + 10;
const int M = 3;
 
int parent[N];
int d[N];
 
void init() {
    for (int i = 0; i <= n; i++) {
        parent[i] = i;
        d[i] = 0;
    }
}
 
int find(int x) {
    if (x != parent[x]) {
        int oldParent = parent[x];
        parent[x] = find(parent[x]);
        d[x] = (d[x] + d[oldParent]) % M;
    }
    return parent[x];
}
 
bool D1(int x, int y) {
    int p1 = find(x);
    int p2 = find(y);
 
    if (p1 == p2) {
        return d[x] % M == d[y] % M;
    }
 
    parent[p2] = p1;
    d[p2] = ((d[x] - d[y]) + M) % M;
    return true;
}
 
bool D2(int x, int y) {
    int p1 = find(x);
    int p2 = find(y);
 
    if (p1 == p2) {
        return d[x] % M == (d[y]+1) % M;
    }
 
    parent[p2] = p1;
    d[p2] = ((d[x]-d[y]-1) + M) % M;
    return true;
}
 
int main(void) {
    int res = 0;
 
    cin >> n;
    init();
 
    cin >> k;
    while (k--) {
        cin >> op >> x >> y;
        if (x > n || y > n) {
            res += 1;
        } else {
            if (op == 'A') {
                if (D1(x, y) == false) {
                    res += 1;
                }
            }
            if (op == 'B') {
                if (D2(x, y) == false) {
                    res += 1;
                }
            }
        }
    }
 
    cout << res << endl;
 
    return 0;
}
```



---


---
title: '蓝桥杯--最大比例'
categories:
- 蓝桥杯
tags:
- 最大公约数
- 数论
- 算法


---

内容简介 : 蓝桥杯历年题目  

---

- 试题内容  ---   最大比例

  X星球的某个大奖赛设了 MM 级奖励。

  每个级别的奖金是一个正整数。

  并且，相邻的两个级别间的比例是个固定值。

  也就是说：所有级别的奖金数构成了一个等比数列。

  比如：16,24,36,5416,24,36,54，其等比值为：3/23/2。

  现在，我们随机调查了一些获奖者的奖金数。

  请你据此推算可能的最大的等比值。

  #### 输入格式

  第一行为数字 NN ，表示接下的一行包含 NN 个正整数。

  第二行 NN 个正整数 XiXi，用空格分开，每个整数表示调查到的某人的奖金数额。

  #### 输出格式

  一个形如 A/BA/B 的分数，要求 A、BA、B 互质，表示可能的最大比例系数。

  #### 数据范围

  0<N<1000<N<100
  0<Xi<10120<Xi<1012
  数据保证一定有解。

  #### 输入样例1：

  ```
  3
  1250 200 32
  ```

  #### 输出样例1：

  ```
  25/4
  ```

  #### 输入样例2：

  ```
  4
  3125 32 32 200
  ```

  #### 输出样例2：

  ```
  5/2
  ```

  #### 输入样例3：

  ```
  3
  549755813888 524288 2
  ```

  #### 输出样例3：

  ```
  4/1
  ```

---

* 我的代码

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N = 110;
typedef long long LL;
LL x[N],a[N],b[N];
int n;

//辗转相减法
LL gcd(LL a,LL b)
{
    return b ? gcd(b,a%b) : a; 
}
//更相减损术
LL gcd_sub(LL a,LL b)
{
    if(a < b) swap(a,b);
    if(b == 1) return a;
    return gcd_sub(b,a/b);
}

int main()
{
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        cin >> x[i];
    }
    sort(x, x + n);
    int cnt = 0;
    for(int i = 1; i < n; i++)
    {
        if(x[i] != x[i - 1])
        {
            LL d = gcd(x[i],x[0]);
            a[cnt] = x[i] / d;
            b[cnt] = x[0] / d;
            cnt ++;
        }
    }
    
    LL up = a[0],down = b[0];
    
    for(int i = 1; i < cnt; i++)
    {
        up = gcd_sub(up,a[i]);
        down = gcd_sub(down,b[i]);
    }
    cout << up << "/" << down << endl;
    return 0;
}
```



---


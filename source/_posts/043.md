---
title: '面试题1 -- 单链表的快速排序'
categories:
- 面试题
tags:
- 链表
- 快速排序


---

内容简介 : 常见面试题

---

- 试题内容  ---  单链表的快速排序

  给定一个单链表，请使用快速排序算法对其排序。

  要求：期望平均时间复杂度为 O(nlogn)O(nlogn)，期望额外空间复杂度为 O(logn)O(logn)。

  **思考题：** 如果只能改变链表结构，不能修改每个节点的val值该如何做呢？

  #### 数据范围

  链表中的所有数大小均在 intint 范围内，链表长度在 [0,10000][0,10000]。

  #### 输入样例：

  ```
  [5, 3, 2]
  ```

  #### 输出样例：

  ```
  [2, 3, 5]
  ```

---

* 思路： 不能直接改变链表的值,但是可以改变链表的指针顺序,那么就和数组的快速排序判断边界问题不大相关了,但是我们可以创建三个子链表 : left, mid, right; 分别模拟记录排序的顺序,最后进行递归循环操作,然后实现链表的拼接就可以了。
* 我们这种写法的快速排序是稳定的,是有区别与数组的快排的。时间复杂度是: O(nlogn),递归层数一共是loogn
* 我的代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* get_tail(ListNode* head){ //找到队尾函数
        while(head->next){
            head = head->next;
        }
        return head;
    }
    ListNode* quickSortList(ListNode* head) {
        if(!head || !head-> next){
            return head;
        }
        auto left = new ListNode(-1),mid = new ListNode(-1),right = new ListNode(-1);
        auto ltail = left,mtail = mid,rtail = right;
        int values = head->val; //快速排序的分界点
        
        //分段
        for(auto p = head; p; p = p -> next)
        {
            if(p -> val < values){
                ltail = ltail->next = p;
            }else if(p -> val == values){
                mtail = mtail->next = p;
            }else{
                rtail = rtail->next = p;
            }
        }
        
        ltail->next = mtail->next = rtail->next = NULL; //加上尾节点
        left  -> next = quickSortList(left -> next); //递归排序
        right -> next = quickSortList(right -> next);
        
        //拼接
        get_tail(left) -> next = mid -> next;
        get_tail(left) -> next = right -> next;
        
        
        auto p = left -> next; //使用C89的动态类型 自动选择,简便运算。
        delete left; //释放内存
        delete mid;
        delete right;
        return p;
    }
};
```



---

